
/** 
 * This code was auto-generated by write_check.py. Do not edit here!
 * 
 * Utilities for checking the CPU instruction set
 *
 * https://en.wikipedia.org/wiki/CPUID
 *
 * See: http://newbiz.github.io/cpp/2010/12/20/Playing-with-cpuid.html
 * ... with corrections and modifications...
 */


#ifdef _MSC_VER
    #include <intrin.h>
#else
    #include <cpuid.h>
#endif
#include "cImageD11.h"
#include "check_cpu_auto.h"

static uint32_t idBits[4 * NCALL];
static int needread = 1;

/* Use static globals here 
/* Results of calls to cpuid 
/* Stuff to look for : EAX call, A|B|C|D, bit position 
 *  0  : {B,D,C} = name, A = maxcall
 *  1  :  4A, 5B, 6C, 7D
 *      A = Processor information
 *      B = Additional information
 *      C = Features
 *      D = Features
 *  2  : Cache and TLB Descriptor information
 *  3  : Processor Serial Number
 * EAX=4 and EAX=Bh: Intel thread/core and cache topology
 * EAX=7, ECX=0: Extended Features
 * EAX=80000000h: Get Highest Extended Function Implemented : 
 *                The highest calling parameter is returned in EAX.
 * EAX=80000001h: Extended Processor Info and Feature Bits
 * EAX=80000002h,80000003h,80000004h: Processor Brand String
 * EAX=80000005h: L1 Cache and TLB Identifiers
 * EAX=80000006h: Extended L2 Cache Features
 * EAX=80000007h: Advanced Power Management Information
 * EAX=80000008h: Virtual and Physical address Sizes
 * EAX=8FFFFFFFh: AMD Easter Egg
 */



/**
 * Calls cpuid and stores results of eax,ebx,ecx,edx in idBits[op*4:op*4+4]
 * __cpuid_count needed for > XXX
 */
#include <stdio.h>
void readcpuid( ) {
  // MSVC and gcc both provide a __cpuid function
  uint32_t j, i;
  #ifdef __GNUC__
  uint32_t  a, b, c, d;
  #endif
  if( needread ){
    for(j=0;j<4*NCALL;j++) idBits[j]=0;
    i = 0;
    while(i<=NCALL){
      #if defined(__GNUC__)
      __cpuid_count( i, 0, a, b, c, d);
      idBits[i*4  ] = a;
      idBits[i*4+1] = b;
      idBits[i*4+2] = c;
      idBits[i*4+3] = d;
      #elif defined(_WIN32)
      __cpuidex( &idBits[i*4], i, 0 );
      #endif
        if( i > idBits[EAXMAX] ) break;

/*      printf("readcpiud : %d ",i);
      for(j=0;j<4;j++){ printf(" %08x ", idBits[i*4+j]); }
      printf("\n");
*/
      i++;
      
    }
    needread = 0;
  }
}


/**
 * Retrieve the processor name.
 * \param name Preallocated string containing at least room for 13 characters. Will
 *             contain the name of the processor.
 */
void cpuidProcessorName( char* name ){
  readcpuid();
  name[0]  = (idBits[1]    ) & 0xFF;
  name[1]  = (idBits[1]>> 8) & 0xFF;
  name[2]  = (idBits[1]>>16) & 0xFF;
  name[3]  = (idBits[1]>>24) & 0xFF;
  name[4]  = (idBits[3]    ) & 0xFF;
  name[5]  = (idBits[3]>> 8) & 0xFF;
  name[6]  = (idBits[3]>>16) & 0xFF;
  name[7]  = (idBits[3]>>24) & 0xFF;
  name[8]  = (idBits[2]    ) & 0xFF;
  name[9]  = (idBits[2]>> 8) & 0xFF;
  name[10] = (idBits[2]>>16) & 0xFF;
  name[11] = (idBits[2]>>24) & 0xFF;
  name[12] = 0;
}

uint32_t maxcall(){
    readcpuid();
    return idBits[0];
}


int flag_SSE(){
 if(needread) readcpuid();
 return (idBits[7] & ( 1 << 25))>0;
}
int flag_SSE2(){
 if(needread) readcpuid();
 return (idBits[7] & ( 1 << 26))>0;
}
int flag_SSE3(){
 if(needread) readcpuid();
 return (idBits[6] & ( 1 << 0))>0;
}
int flag_FMA3(){
 if(needread) readcpuid();
 return (idBits[6] & ( 1 << 12))>0;
}
int flag_SSE41(){
 if(needread) readcpuid();
 return (idBits[6] & ( 1 << 19))>0;
}
int flag_SSE42(){
 if(needread) readcpuid();
 return (idBits[6] & ( 1 << 20))>0;
}
int flag_MOVBE(){
 if(needread) readcpuid();
 return (idBits[6] & ( 1 << 22))>0;
}
int flag_XSAVE(){
 if(needread) readcpuid();
 return (idBits[6] & ( 1 << 26))>0;
}
int flag_OSXSAVE(){
 if(needread) readcpuid();
 return (idBits[6] & ( 1 << 27))>0;
}
int flag_AVX(){
 if(needread) readcpuid();
 return (idBits[6] & ( 1 << 28))>0;
}
int flag_AVX2(){
 if(needread) readcpuid();
 return (idBits[29] & ( 1 << 5))>0;
}
int flag_AVX512F(){
 if(needread) readcpuid();
 return (idBits[29] & ( 1 << 16))>0;
}

int i_have_SSE2(){
  return (flag_SSE2()>0);
}
int i_have_SSE42(){
  return (flag_SSE42()>0);
}
int i_have_AVX(){
    return (flag_XSAVE()>0)&(flag_OSXSAVE()>0)&(flag_AVX()>0);
}
int i_have_AVX2(){
    return (flag_AVX()>0)&(flag_MOVBE()>0)&(flag_FMA3()>0)&(flag_AVX2()>0);
}
int i_have_AVX512F(){
    return (flag_OSXSAVE()>0)&(flag_AVX512F()>0);
}

